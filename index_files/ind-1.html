<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Galaxy Mode (Halo & Gradient)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-element { display: none; }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 10; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #88ccff;
            transition: opacity 0.5s; pointer-events: none;
        }
        .spinner {
            width: 40px; height: 40px; border: 2px solid #88ccff; border-top: 2px solid transparent;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>Generating Galactic Halo...</div>
    </div>

    <video id="video-element"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        const CONFIG = {
            particleCount: 200000, 
            haloCount: 20000,      // ★追加：ハロー（球状星団）の数
            particleSize: 1.2,     
            bloomStrength: 0.5,    // 輝きを抑えてドライな質感に
            bloomRadius: 0.4,
            rotationSpeed: 0.002
        };

        const STATE = {
            handDistance: 0, 
            targetHandDistance: 0,
        };

        // --- Vertex Shader ---
        const vertexShader = `
            uniform float uTime;
            uniform float uSize;
            uniform float uExpansion;
            
            attribute float aScale;
            attribute vec3 aColor; 
            attribute vec3 aRandomness;
            
            varying vec3 vColor;
            varying float vDistance; // 中心からの距離をフラグメントに送る

            void main() {
                vec3 pos = position;

                // 拡張ロジック
                vec3 dir = normalize(pos);
                float dist = length(pos);
                float factor = smoothstep(1.0, 15.0, dist); 
                pos += dir * uExpansion * 8.0 * factor;

                // 揺らぎ
                pos += aRandomness * (sin(uTime * 0.5) * 0.02);

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                gl_PointSize = uSize * aScale * (350.0 / -mvPosition.z);
                
                vColor = aColor;
                vDistance = dist; // 距離を渡す
            }
        `;

        // --- Fragment Shader ---
        const fragmentShader = `
            varying vec3 vColor;
            varying float vDistance;

            void main() {
                vec2 center = gl_PointCoord - 0.5;
                float distToCenter = length(center);
                
                // 粒子の形状（ソフトな丸）
                float alphaPoint = 1.0 - smoothstep(0.0, 0.5, distToCenter);
                alphaPoint = pow(alphaPoint, 2.0);

                // ★ここが重要：銀河全体のフェードアウト★
                // 中心(0.0)から離れるほど透明にする
                // 10.0あたりから薄くなり始め、25.0で完全に消える（自然な減衰）
                float galaxyFade = 1.0 - smoothstep(8.0, 28.0, vDistance);

                if (alphaPoint < 0.01) discard;

                // 距離に応じてさらにアルファを下げる（遠くの星は薄く）
                gl_FragColor = vec4(vColor, alphaPoint * galaxyFade);
            }
        `;

        class ParticleSystem {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.initThree();
                this.initGalaxy(); 
                this.initHalo(); // ★ハロー（球状星団）を追加
                this.initPostProcessing();
                this.initMediaPipe();
                this.initGUI();
                
                this.clock = new THREE.Clock();
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);

                window.addEventListener('resize', this.onResize.bind(this));
                setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000); 
                
                this.camera = new THREE.PerspectiveCamera(60, this.width / this.height, 0.1, 3000);
                this.camera.position.set(0, 20, 15); 
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);
            }

            initGalaxy() {
                const count = CONFIG.particleCount;
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const scales = new Float32Array(count);
                const randomness = new Float32Array(count * 3);

                const colorCore = new THREE.Color(0xffeebb); 
                const colorArm = new THREE.Color(0x99ccff);  
                const colorNebula = new THREE.Color(0xff55aa); 
                const colorHaze = new THREE.Color(0x223355); 

                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    let x, y, z;
                    let color = new THREE.Color();
                    let scale = 1.0;

                    const r = Math.random();

                    // --- 1. バルジ（中心核）: 10% ---
                    if (r < 0.10) {
                        const dist = Math.random() * 3.0;
                        const angle = Math.random() * Math.PI * 2;
                        x = dist * Math.cos(angle) * 1.5; 
                        z = dist * Math.sin(angle) * 0.8;
                        y = (Math.random() - 0.5) * (2.5 - dist * 0.6);

                        color.copy(colorCore);
                        if (dist < 1.0) color.lerp(new THREE.Color(0xffffff), 0.6);
                        
                        scale = Math.random() * 2.0 + 1.5;
                    }
                    // --- 2. ディスク全体（Haze / 隙間埋め）: 40% ---
                    else if (r < 0.50) {
                        // ★修正：中心から離れるほど密度を下げる（指数関数的分布）★
                        // Math.random() の二乗を使うなどで、外側を疎にする
                        const dist = (Math.pow(Math.random(), 1.5)) * 25.0 + 2.0;
                        const angle = Math.random() * Math.PI * 2;
                        
                        x = Math.cos(angle) * dist;
                        z = Math.sin(angle) * dist;
                        y = (Math.random() - 0.5) * 0.6; 

                        color.copy(colorHaze);
                        color.lerp(new THREE.Color(0x000000), Math.random() * 0.5);
                        
                        scale = Math.random() * 0.8 + 0.2; 
                    }
                    // --- 3. 渦巻き腕 (Spiral Arms) : 50% ---
                    else {
                        const armIndex = i % 2; 
                        const armOffset = Math.PI * armIndex;
                        // 腕の長さを伸ばす
                        const dist = Math.random() * 18.0 + 3.0; 
                        const spiralAngle = dist * 0.4; 
                        let angle = armOffset + spiralAngle;
                        
                        // 散らばり（外側ほど大きく）
                        const spread = (Math.random() - 0.5) * 1.5; 
                        angle += spread * (0.5 + dist * 0.05);

                        x = Math.cos(angle) * dist;
                        z = Math.sin(angle) * dist;
                        y = (Math.random() - 0.5) * 0.4;

                        if (dist < 5.0) { x *= 1.3; z *= 0.7; }

                        if (Math.random() < 0.15) { 
                            color.copy(colorNebula);
                            scale = Math.random() * 2.5 + 1.5; 
                            x += (Math.random()-0.5)*0.5;
                            z += (Math.random()-0.5)*0.5;
                        } else {
                            color.copy(colorArm);
                            // 外側ほど暗く
                            color.lerp(new THREE.Color(0x001133), (dist - 3.0) / 18.0);
                            scale = Math.random() * 1.2 + 0.6;
                        }
                    }

                    positions[i3] = x;
                    positions[i3+1] = y;
                    positions[i3+2] = z;

                    colors[i3] = color.r;
                    colors[i3+1] = color.g;
                    colors[i3+2] = color.b;

                    scales[i] = scale;
                    
                    randomness[i3] = Math.random()-0.5;
                    randomness[i3+1] = Math.random()-0.5;
                    randomness[i3+2] = Math.random()-0.5;
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
                geometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 3));

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uSize: { value: CONFIG.particleSize },
                        uExpansion: { value: 0 }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.points = new THREE.Points(geometry, this.material);
                this.points.rotation.x = -0.5; 
                this.points.rotation.z = -0.1; 
                this.scene.add(this.points);
            }

            // ★新規：ハロー（球状星団）の生成★
            initHalo() {
                const count = CONFIG.haloCount;
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const scales = new Float32Array(count);
                const randomness = new Float32Array(count * 3);

                const colorHalo = new THREE.Color(0xddddaa); // 古い星（少し黄色）

                for(let i=0; i<count; i++) {
                    // 円盤外に球状に散らす
                    const r = 5.0 + Math.pow(Math.random(), 2.0) * 30.0; // 円盤より大きく、中心に寄り気味に
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1); // 球面分布

                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta) * 0.6; // 少しだけ平たく
                    let z = r * Math.cos(phi);

                    // 円盤付近は除外する（円盤の星と被らないように）
                    if (Math.abs(y) < 2.0 && Math.sqrt(x*x + z*z) < 15.0) {
                        y *= 3.0; // 上下に飛ばす
                    }

                    const i3 = i * 3;
                    positions[i3] = x;
                    positions[i3+1] = y;
                    positions[i3+2] = z;

                    // ハローの星は暗く小さい
                    const c = colorHalo.clone().multiplyScalar(0.3 + Math.random() * 0.3);
                    colors[i3] = c.r;
                    colors[i3+1] = c.g;
                    colors[i3+2] = c.b;

                    scales[i] = Math.random() * 0.8 + 0.4;
                    randomness[i3] = Math.random(); 
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
                geometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 3));

                // ハロー用のマテリアル（メインと同じシェーダーを流用）
                this.haloMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uSize: { value: CONFIG.particleSize },
                        uExpansion: { value: 0 } // ハローも一緒に広がるようにする
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.haloPoints = new THREE.Points(geometry, this.haloMaterial);
                this.haloPoints.rotation.x = -0.5; // メインと角度を合わせる
                this.haloPoints.rotation.z = -0.1;
                this.scene.add(this.haloPoints);
            }

            initPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(this.width, this.height), 1.5, 0.4, 0.85);
                this.bloomPass.strength = CONFIG.bloomStrength;
                this.bloomPass.radius = CONFIG.bloomRadius;
                this.composer.addPass(this.bloomPass);
            }

            initMediaPipe() {
                const video = document.getElementById('video-element');
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                hands.onResults(this.onHandsResults.bind(this));
                const camera = new Camera(video, {
                    onFrame: async () => await hands.send({image: video}),
                    width: 640, height: 480
                });
                camera.start().catch(e => console.log(e));
            }

            onHandsResults(results) {
                let newTargetDistance = 0;
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lms = results.multiHandLandmarks;
                    if (lms.length === 2) {
                        const dist = Math.sqrt(Math.pow(lms[0][9].x - lms[1][9].x, 2) + Math.pow(lms[0][9].y - lms[1][9].y, 2));
                        newTargetDistance = THREE.MathUtils.clamp((dist - 0.1) * 2.5, 0, 2.0);
                    }
                }
                STATE.targetHandDistance = newTargetDistance;
            }

            initGUI() {
                const gui = new GUI({ title: 'Real Galaxy Settings' });
                gui.domElement.style.marginTop = "60px";
                const visual = gui.addFolder('Visuals');
                visual.add(CONFIG, 'bloomStrength', 0, 3).name('Glow').onChange(v => this.bloomPass.strength = v);
                visual.add(CONFIG, 'particleSize', 0.1, 5).name('Star Size').onChange(v => {
                    this.material.uniforms.uSize.value = v;
                    this.haloMaterial.uniforms.uSize.value = v;
                });
                visual.add(CONFIG, 'rotationSpeed', 0, 0.05).name('Speed');
            }

            onResize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.camera.aspect = this.width / this.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.width, this.height);
                this.composer.setSize(this.width, this.height);
            }

            animate() {
                requestAnimationFrame(this.animate);
                const time = this.clock.getElapsedTime();

                STATE.handDistance += (STATE.targetHandDistance - STATE.handDistance) * 0.05;

                // メイン銀河更新
                this.material.uniforms.uTime.value = time;
                this.material.uniforms.uExpansion.value = STATE.handDistance;
                this.points.rotation.y -= CONFIG.rotationSpeed; 

                // ハロー更新
                this.haloMaterial.uniforms.uTime.value = time;
                this.haloMaterial.uniforms.uExpansion.value = STATE.handDistance;
                // ハローはゆっくり、あるいはランダムに動くのがリアルだが、
                // ここでは銀河の重力に引かれているとして少しゆっくり回転させる
                this.haloPoints.rotation.y -= CONFIG.rotationSpeed * 0.3;

                this.composer.render();
            }
        }
        new ParticleSystem();
    </script>
</body>
</html>