<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System: Distributed Map</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center; 
            color: #88ccff; font-family: 'Courier New', sans-serif; font-weight: bold;
            pointer-events: none; letter-spacing: 4px; font-size: 14px;
            text-shadow: 0 0 10px #0088ff; opacity: 0.9;
        }
        
        #nav-panel {
            position: absolute; top: 60px; right: 20px; width: 220px;
            background: rgba(0, 5, 10, 0.8);
            border-right: 2px solid rgba(68, 136, 255, 0.5);
            border-bottom: 1px solid rgba(68, 136, 255, 0.2);
            padding: 10px;
            font-family: 'Courier New', sans-serif;
            color: #aaddff;
            max-height: 70vh;
            overflow-y: auto;
            backdrop-filter: blur(8px);
        }
        #nav-panel h3 {
            margin: 0 0 10px 0; font-size: 14px; text-align: center; 
            border-bottom: 1px solid rgba(68, 136, 255, 0.3); padding-bottom: 5px; letter-spacing: 2px;
        }
        .nav-group { margin-bottom: 15px; }
        .nav-group-title { font-size: 10px; color: #6688aa; margin-bottom: 3px; text-transform: uppercase; letter-spacing: 1px; }
        
        .target-btn {
            display: block; width: 100%; padding: 5px 8px; margin-bottom: 2px;
            background: transparent; border: none; border-left: 2px solid transparent;
            color: #88aaff; cursor: pointer; text-align: left; font-size: 13px;
            transition: all 0.2s; font-family: 'Courier New', sans-serif;
        }
        .target-btn:hover { background: rgba(0, 100, 255, 0.1); border-left: 2px solid #44aaff; color: #ffffff; }
        .target-btn.active { background: rgba(0, 100, 255, 0.2); border-left: 2px solid #00ffff; color: #00ffff; text-shadow: 0 0 5px #00ffff; }
        
        .warp-active { border-left: 2px solid #ff4444 !important; color: #ffaaaa !important; }
        .orion-btn { border-left: 2px solid #ff8844 !important; color: #ffccaa !important; background: rgba(60,20,0,0.2); }
        .nebula-btn { border-left: 2px solid #ff00ff !important; color: #ffccff !important; background: rgba(50,0,50,0.2); }
        .trappist-btn { border-left: 2px solid #ff8800 !important; color: #ffccaa !important; background: rgba(50,20,0,0.2); }
        .super-ring-btn { border-left: 2px solid #ffaa00 !important; color: #ffeeaa !important; background: rgba(50,40,0,0.3); font-weight: bold; }
        .extreme-btn { border-left: 2px solid #00aaff !important; color: #ccffff !important; background: rgba(0,20,50,0.3); font-weight: bold; }
        .pleiades-btn { border-left: 2px solid #00aaff !important; color: #ccffff !important; background: rgba(0,30,60,0.3); }

        #reset-btn {
            width: 100%; padding: 6px; background: rgba(200, 50, 50, 0.2); 
            border: 1px solid rgba(255, 80, 80, 0.4); color: #ffaaaa;
            font-size: 12px; cursor: pointer; margin-top: 10px; transition: all 0.2s;
        }
        #reset-btn:hover { background: rgba(200, 50, 50, 0.5); color: #fff; }

        #data-monitor {
            position: absolute; bottom: 80px; left: 20px; width: 380px;
            background: rgba(5, 10, 15, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 4px solid #00ffff;
            padding: 20px;
            font-family: 'Courier New', monospace;
            color: #00ffff;
            backdrop-filter: blur(8px);
            display: none;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
        }
        #monitor-name { margin: 0 0 10px 0; font-size: 22px; letter-spacing: 2px; text-shadow: 0 0 8px #00ffff; border-bottom: 1px solid rgba(0, 255, 255, 0.3); padding-bottom: 5px; }
        
        .data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px 15px; margin-bottom: 15px; }
        .data-row { display: flex; justify-content: space-between; font-size: 12px; border-bottom: 1px dashed rgba(0,255,255,0.1); padding-bottom: 2px;}
        .data-label { color: #88aaff; }
        .data-val { color: #ffffff; font-weight: bold; text-align: right; }
        
        #data-desc-box {
            background: rgba(0, 0, 0, 0.3); padding: 10px; border: 1px solid rgba(0, 255, 255, 0.1);
            min-height: 80px;
        }
        #data-desc {
            font-size: 13px; line-height: 1.5; color: #ccffff; margin: 0;
        }
        .cursor { display: inline-block; width: 8px; height: 14px; background: #00ffff; animation: blink 1s infinite; vertical-align: middle; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        #bottom-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px;
        }
        #time-panel {
            width: 300px; height: 40px;
            background: rgba(0, 10, 20, 0.8);
            border: 1px solid #4488ff; border-radius: 20px;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); padding: 0 15px;
            color: #00ffff; font-family: 'Courier New', sans-serif; font-size: 12px;
        }
        .toggle-btn {
            height: 40px; padding: 0 15px;
            background: rgba(0, 50, 20, 0.8);
            border: 1px solid #00ff88; border-radius: 20px;
            color: #00ff88; font-family: 'Courier New', sans-serif; font-size: 12px;
            cursor: pointer; display: flex; align-items: center;
            transition: all 0.2s;
        }
        .toggle-btn:hover { background: rgba(0, 80, 40, 0.9); box-shadow: 0 0 10px #00ff88; }
        .toggle-btn.off { border-color: #666; color: #888; background: rgba(20,20,20,0.8); }
        #time-slider { width: 150px; margin: 0 15px; cursor: pointer; }
        .time-label { width: 50px; text-align: center; }
        
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #4488ff; border-radius: 2px; }
    </style>
</head>
<body>
    <div id="info">SYSTEM: COORDINATES SCATTERED | OVERLAP RESOLVED</div>
    
    <div id="nav-panel">
        <h3>NAVIGATION</h3>
        <div id="target-list"></div>
        <button id="reset-btn">SOLAR SYSTEM RESET</button>
    </div>

    <div id="data-monitor">
        <h2 id="monitor-name">TARGET</h2>
        <div class="data-grid">
            <div class="data-row"><span class="data-label">CLASS</span><span class="data-val" id="monitor-class">-</span></div>
            <div class="data-row"><span class="data-label">DIAMETER</span><span class="data-val" id="monitor-size">-</span></div>
            <div class="data-row"><span class="data-label">STATUS</span><span class="data-val" id="monitor-temp">-</span></div>
            <div class="data-row"><span class="data-label">DISTANCE</span><span class="data-val" id="monitor-dist">-</span></div>
        </div>
        <div id="data-desc-box">
            <p id="data-desc"></p>
        </div>
    </div>

    <div id="bottom-panel">
        <button id="hz-toggle" class="toggle-btn off">HABITABLE ZONE: OFF</button>
        <div id="time-panel">
            <span class="time-label">PAUSE</span>
            <input type="range" id="time-slider" min="0" max="5.0" step="0.1" value="1.0">
            <span class="time-label" id="speed-display">1.0x</span>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- JP DATABASE ---
        const infoDatabase = {
            "Mercury": { class: "岩石惑星", size: "4,880 km", temp: "167°C", desc: "太陽系最小の惑星。太陽に最も近く、大気がほぼ無いため昼夜の温度差が激しい。ローマ神話の伝令神メルクリウスに由来する。" },
            "Venus": { class: "岩石惑星", size: "12,104 km", temp: "464°C", desc: "厚い有毒な大気と暴走した温室効果により、太陽系で最も高温な惑星。宵の明星、明けの明星として有名" },
            "Earth": { class: "岩石惑星", size: "12,742 km", temp: "15°C (平均)", desc: "青い方舟。液体の水と生命が存在する唯一の既知の天体。他の惑星にないプレート運動が存在する。" },
            "Mars": { class: "岩石惑星", size: "6,779 km", temp: "-65°C", desc: "赤い惑星。太陽系最大の火山「オリンポス山」がある。地球同様に四季が存在し1日の長さが25.5hのため移住の候補地" },
            "Jupiter": { class: "巨大ガス惑星", size: "139,820 km", temp: "-110°C", desc: "太陽系最大の惑星。巨大な嵐「大赤斑」や70個以上の衛星を持つ。高速自転によって磁場の放射線が土星にまで伸びる" },
            "Saturn": { class: "巨大ガス惑星", size: "116,460 km", temp: "-140°C", desc: "氷と岩石でできた壮大で美しい「環（リング）」を持つ惑星。スーパーサターンではない" },
            "Uranus": { class: "巨大氷惑星", size: "50,724 km", temp: "-195°C", desc: "太陽系で最も低温な大気を持つ。自転軸がほぼ横倒しになっている。" },
            "Neptune": { class: "巨大氷惑星", size: "49,244 km", temp: "-200°C", desc: "太陽から最も遠い惑星。超音速の風が吹き荒れる極寒の世界。" },
            "Pluto": { class: "準惑星", size: "2,377 km", temp: "-229°C", desc: "カイパーベルトにある準惑星。ハート型の氷河地形を持つ。" },
            "Haumea": { class: "準惑星", size: "1,600 km", temp: "-241°C", desc: "高速回転によりラグビーボール状に変形した準惑星。2つの衛星を持ち70kmの環を持ちます" },
            "Makemake":{ class: "準惑星", size: "1,400 km", temp: "-243°C", desc:"カイパーベルトに存在する赤みがかった色を持つ。他の準惑星と比べ表面がメタンやエタンの氷のため反射率が高く明るく輝きます。"},
            "Eris": { class: "準惑星", size: "2,326 km", temp: "-243°C", desc: "冥王星とほぼ同じ大きさを持つ、散乱円盤天体の巨大な準惑星。" },
            "Sedna": { class: "太陽系外縁天体", size: "1,000 km", temp: "-240°C", desc: "太陽系の最果てにある、非常に遠い軌道を持つ赤い天体。" },
            "Voyager 1": { class: "宇宙探査機", size: "722 kg", temp: "星間空間", desc: "地球から最も遠くにある人工物。現在は太陽系を離れ、星間空間を航行中。" },
            "Cassini": { class: "宇宙探査機", size: "5,712 kg", temp: "任務終了", desc: "土星とその衛星を詳しく調査した伝説的な探査機。" },
            "Juno": { class: "宇宙探査機", size: "3,625 kg", temp: "稼働中", desc: "木星の極軌道を周回し、その内部構造や磁場を調査している。" },
            "Alpha Centauri A": { class: "G型主系列星", size: "太陽の1.22倍", temp: "5,790 K", desc: "最も近い恒星系の主星。太陽によく似た黄色い星。" },
            "Alpha Centauri B": { class: "K型主系列星", size: "太陽の0.86倍", temp: "5,260 K", desc: "アルファ・ケンタウリ系の伴星。オレンジ色の星。" },
            "Proxima Centauri": { class: "赤色矮星", size: "太陽の0.15倍", temp: "3,042 K", desc: "太陽に最も近い恒星（4.24光年）。小さく活動的な赤色矮星。" },
            "Proxima b": { class: "系外惑星", size: "地球の1.1倍", temp: "-39°C", desc: "プロキシマ・ケンタウリのハビタブルゾーンにある地球サイズの惑星。" },
            "Sirius A": { class: "A型主系列星", size: "太陽の1.7倍", temp: "9,940 K", desc: "全天で最も明るく輝く恒星。地球から8.6光年の距離にある。" },
            "Sirius B": { class: "白色矮星", size: "地球と同等", temp: "25,200 K", desc: "シリウスの伴星。かつては巨大な星だったが、現在は燃え尽きて芯だけが残っている。" },
            "Gliese 710": { class: "オレンジ色矮星", size: "太陽の0.6倍", temp: "4,250 K", desc: "約130万年後に太陽系へ1.1光年まで大接近すると予測されている恒星。" },
            "Black Hole": { class: "特異点", size: "事象の地平面", temp: "測定不能", desc: "重力が極限まで強く、光さえも脱出できない時空の領域。" },
            "Pulsar": { class: "中性子星", size: "20 km", temp: "100万度", desc: "超高速で回転しながら強力なビームを放つ、高密度の中性子星。" },
            "Halley's Comet": { class: "短周期彗星", size: "11 km", temp: "昇華中", desc: "約76年周期で地球に接近する、最も有名な彗星。" },
            "TRAPPIST-1": { class: "赤色矮星", size: "太陽の0.11倍", temp: "2,566 K", desc: "7つの地球サイズ惑星を持つ小さな恒星。惑星同士が非常に密集している。" },
            "TRAPPIST-1e": { class: "系外惑星", size: "地球の0.92倍", temp: "-22°C", desc: "トラピスト1系の中で最も地球に似ていると考えられる惑星。" },
            "Orion Nebula": { class: "散光星雲", size: "24 光年", temp: "10,000 K", desc: "新しい星が生まれている巨大な星のゆりかご。肉眼でも見える。" },
            "Betelgeuse": { class: "赤色超巨星", size: "太陽の1000倍", temp: "3,500 K", desc: "寿命が尽きかけている巨大な恒星。オリオン座の右肩。" },
            "Rigel": { class: "青色超巨星", size: "太陽の79倍", temp: "12,100 K", desc: "オリオン座で最も明るい星。極めて高温で強力な光を放つ。" },
            "VFTS 102": { class: "O型青色巨星", size: "太陽の25倍", temp: "36,000 K", desc: "時速160万kmで自転する星。扁平につぶれ、赤道からガスを放出している。" },
            "J1407b": { class: "巨大ガス惑星", size: "木星の約20倍", temp: "不明", desc: "スーパーサターン。1億2000万kmに及ぶ巨大な環を持つ。" },
            "The Pleiades": { class: "散開星団", size: "約10光年", temp: "10,000K+", desc: "「すばる」として知られる若い青色巨星の集団。美しい反射星雲に包まれている。" },
            "L1448-MM": { class: "クラス0原始星", size: "形成中", temp: "低温", desc: "ペルセウス座分子雲にある生まれたての星。極方向へ激しいジェットを噴き出している。" }
        };

        // --- Texture Generator ---
        function createPlanetTexture(baseColorHex, type) {
            const size = 512; const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d');
            const baseColor = new THREE.Color(baseColorHex);
            ctx.fillStyle = `#${baseColor.getHexString()}`; ctx.fillRect(0, 0, size, size);
            if (type === 'gas') {
                for (let i = 0; i < 20; i++) {
                    const y = Math.random() * size; ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.1})`; ctx.fillRect(0, y, size, Math.random() * 60 + 10);
                }
            } else if (type === 'rock' || type === 'ice' || type === 'comet') {
                for (let i = 0; i < 300; i++) {
                    const x = Math.random() * size; const y = Math.random() * size; const r = Math.random() * 15 + 2;
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.2 + 0.1})`; ctx.fill();
                }
                if (type === 'comet') { ctx.fillStyle = 'rgba(255,255,255,0.4)'; for(let i=0;i<50;i++) ctx.fillRect(Math.random()*size,Math.random()*size,20,20); }
            } else if (type === 'star' || type === 'pulsar') {
                const grad = ctx.createRadialGradient(256,256,0, 256,256,256);
                const c1 = baseColor.clone().lerp(new THREE.Color(0xffffff), 0.7).getStyle();
                const c2 = baseColor.getStyle();
                grad.addColorStop(0, c1); grad.addColorStop(1, c2);
                ctx.fillStyle = grad; ctx.fillRect(0,0,512,512);
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createGlowTexture(color) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, new THREE.Color(color).getStyle());
            gradient.addColorStop(0.2, new THREE.Color(color).getStyle());
            gradient.addColorStop(0.5, 'rgba(0,0,0,0.1)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // --- Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.00001);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000000); 
        const initialCamPos = new THREE.Vector3(0, 1500, 3000); camera.position.copy(initialCamPos);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.3;
        renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05; controls.maxDistance = 1000000;
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.7));

        // --- Coordinates (SCATTERED) ---
        // X, Y, Z spread to prevent line-of-sight overlap
        const ALPHA_OFFSET = new THREE.Vector3(100000, 15000, 20000); 
        const PROXIMA_OFFSET = new THREE.Vector3(115000, -5000, -10000);
        const TRAPPIST_OFFSET = new THREE.Vector3(80000, 60000, -80000); 
        const GLIESE_OFFSET = new THREE.Vector3(-60000, -10000, 30000);
        const SIRIUS_OFFSET = new THREE.Vector3(50000, -40000, 50000);
        const BLACKHOLE_OFFSET = new THREE.Vector3(-150000, 20000, 50000);
        const PULSAR_OFFSET = new THREE.Vector3(-200000, 50000, -100000);
        const NEBULA1_OFFSET = new THREE.Vector3(-50000, 80000, -50000);
        const NEBULA2_OFFSET = new THREE.Vector3(120000, -50000, 20000);
        const ORION_OFFSET = new THREE.Vector3(-150000, -80000, 150000);
        const VFTS_OFFSET = new THREE.Vector3(0, 100000, -200000);
        const J1407_OFFSET = new THREE.Vector3(200000, 50000, 200000); 
        const PLEIADES_OFFSET = new THREE.Vector3(-80000, 20000, -80000);

        // --- Lights ---
        scene.add(new THREE.AmbientLight(0x222222, 0.5));
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x080820, 0.3); scene.add(hemiLight);
        const sunLight = new THREE.PointLight(0xffffff, 6.0, 60000); scene.add(sunLight); 
        const aLight = new THREE.PointLight(0xffaa00, 4.0, 20000); aLight.position.copy(ALPHA_OFFSET); scene.add(aLight);
        const pLight = new THREE.PointLight(0xff4400, 3.0, 10000); pLight.position.copy(PROXIMA_OFFSET); scene.add(pLight);
        const tLight = new THREE.PointLight(0xff2200, 4.0, 20000); tLight.position.copy(TRAPPIST_OFFSET); scene.add(tLight); 
        const gLight = new THREE.PointLight(0xffaa55, 3.5, 20000); gLight.position.copy(GLIESE_OFFSET); scene.add(gLight);
        const sLight = new THREE.PointLight(0xaaccff, 5.0, 30000); sLight.position.copy(SIRIUS_OFFSET); scene.add(sLight);
        const bLight = new THREE.PointLight(0xaa00ff, 5.0, 40000); bLight.position.copy(BLACKHOLE_OFFSET); scene.add(bLight);
        const puLight = new THREE.PointLight(0x00ffff, 5.0, 40000); puLight.position.copy(PULSAR_OFFSET); scene.add(puLight);
        const n1Light = new THREE.PointLight(0xff0088, 3.0, 30000); n1Light.position.copy(NEBULA1_OFFSET); scene.add(n1Light);
        const oLight = new THREE.PointLight(0xff4400, 5.0, 50000); oLight.position.copy(ORION_OFFSET); scene.add(oLight);
        const vLight = new THREE.PointLight(0xaaccff, 4.0, 40000); vLight.position.copy(VFTS_OFFSET); scene.add(vLight);
        const jLight = new THREE.PointLight(0xffaa55, 4.0, 30000); jLight.position.copy(J1407_OFFSET); scene.add(jLight);
        const plLight = new THREE.PointLight(0x88aaff, 5.0, 40000); plLight.position.copy(PLEIADES_OFFSET); scene.add(plLight);

        // --- Objects Creation ---
        function createPoints(count, rangeMin, rangeMax, color, size, opacity, shape, offset = new THREE.Vector3(0,0,0), scaleY = 1) {
            const geo = new THREE.BufferGeometry(); const pos = []; const cols = [];
            for(let i=0; i<count; i++) {
                const r = Math.random() * (rangeMax - rangeMin) + rangeMin;
                const theta = Math.random() * Math.PI * 2;
                let x, y, z;
                if (shape === 'sphere') { 
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.sin(phi) * Math.sin(theta); z = r * Math.cos(phi);
                } else if (shape === 'cloud') { 
                    x = (Math.random()-0.5) * rangeMax; y = (Math.random()-0.5) * rangeMax; z = (Math.random()-0.5) * rangeMax;
                } else { 
                    const spread = shape === 'thin' ? 20 : 40;
                    x = Math.cos(theta)*r; y = (Math.random() - 0.5) * spread * scaleY; z = Math.sin(theta)*r;
                }
                pos.push(x + offset.x, y + offset.y, z + offset.z);
                if (color === 'random') {
                    const t = Math.random(); cols.push(t>0.6?0.6:t>0.3?0.5:0.3, t>0.6?0.5:t>0.3?0.5:0.3, t>0.6?0.4:t>0.3?0.5:0.3);
                } else if (color === 'ice') { cols.push(0.5, 0.7, 1.0); }
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            if(cols.length>0) geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
            const mat = new THREE.PointsMaterial({ size: size, color: cols.length>0?0xffffff:color, vertexColors: cols.length>0, transparent: true, opacity: opacity, blending: THREE.AdditiveBlending, sizeAttenuation: true });
            const mesh = new THREE.Points(geo, mat); scene.add(mesh); return mesh;
        }

        // Backgrounds
        createPoints(15000, 2000, 60000, 0xffffff, 3.0, 0.9, 'sphere');
        const asteroidBelt = createPoints(4000, 145, 175, 'random', 2.0, 0.8, 'thin');
        const kuiperBelt = createPoints(3000, 450, 800, 'ice', 1.8, 0.5, 'thick');
        const oortCloud = createPoints(15000, 5000, 50000, 0xaaaaaa, 6.0, 0.15, 'sphere');
        
        const mwCount = 20000; const mwGeo = new THREE.BufferGeometry(); const mwPos = []; const mwCol = [];
        for(let i=0; i<mwCount; i++) {
            const r = Math.random() * 100000 + 20000; const theta = Math.random() * Math.PI * 2; const y = (Math.random() - 0.5) * 8000;
            const cType = Math.random(); if(cType > 0.7) mwCol.push(0.5, 0.2, 0.8); else if (cType > 0.4) mwCol.push(0.2, 0.4, 0.9); else mwCol.push(0.8, 0.8, 0.9);
            mwPos.push(r * Math.cos(theta), y, r * Math.sin(theta));
        }
        mwGeo.setAttribute('position', new THREE.Float32BufferAttribute(mwPos, 3)); mwGeo.setAttribute('color', new THREE.Float32BufferAttribute(mwCol, 3));
        const mwMat = new THREE.PointsMaterial({ size: 100, vertexColors: true, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending, depthWrite: false });
        const milkyWay = new THREE.Points(mwGeo, mwMat); milkyWay.rotation.x = Math.PI / 3; milkyWay.rotation.z = Math.PI / 6; scene.add(milkyWay);

        createPoints(2000, 0, 5000, 0xff0088, 30.0, 0.05, 'cloud', NEBULA1_OFFSET);
        createPoints(1000, 0, 3000, 0xffccff, 20.0, 0.1, 'cloud', NEBULA1_OFFSET);
        createPoints(2000, 0, 4000, 0x00ffaa, 30.0, 0.05, 'cloud', NEBULA2_OFFSET);
        createPoints(2000, 1000, 10000, 0xaaaaff, 3.0, 0.8, 'sphere', ORION_OFFSET);
        createPoints(2000, 1000, 10000, 0xaaccff, 3.0, 0.8, 'sphere', VFTS_OFFSET);
        createPoints(2000, 1000, 10000, 0xffddaa, 3.0, 0.8, 'sphere', J1407_OFFSET); // J1407 BG

        const sun = new THREE.Mesh(new THREE.IcosahedronGeometry(30, 10), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
        sun.add(new THREE.Mesh(new THREE.SphereGeometry(35, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff4400, side: THREE.BackSide, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending })));
        sunLight.add(sun);

        const hzMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88, side: THREE.DoubleSide, transparent: true, opacity: 0.0, blending: THREE.AdditiveBlending, depthWrite: false }); 
        const hzGeos = [];
        function addHZ(radius, width, parent) {
            const geo = new THREE.RingGeometry(radius - width, radius + width, 128);
            const mesh = new THREE.Mesh(geo, hzMaterial); mesh.rotation.x = Math.PI / 2; parent.add(mesh); hzGeos.push(mesh);
        }
        addHZ(100, 15, scene); 
        
        let trackableObjects = []; let currentTarget = null;

        // --- PLEIADES & L1448-MM ---
        const pleiadesGroup = new THREE.Group(); pleiadesGroup.position.copy(PLEIADES_OFFSET); scene.add(pleiadesGroup);
        function createGlowingStar(size, color, x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(size, 8), new THREE.MeshBasicMaterial({ color: color, map: createPlanetTexture(color, 'star') })); group.add(mesh);
            const spriteMat = new THREE.SpriteMaterial({ map: createGlowTexture(color), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMat); sprite.scale.set(size * 6, size * 6, 1); group.add(sprite);
            return { group: group, mesh: mesh, sprite: sprite };
        }
        const alcyone = createGlowingStar(1000, 0xaaccff, 0, 0, 0); pleiadesGroup.add(alcyone.group);
        const maia = createGlowingStar(800, 0x99bbff, 3000, 2000, -1000); pleiadesGroup.add(maia.group);
        createPoints(3000, 0, 8000, 0x88aaff, 50.0, 0.03, 'cloud', PLEIADES_OFFSET);
        trackableObjects.push({ name: "The Pleiades", center: PLEIADES_OFFSET, type: 'star', system: 'pleiades' });

        // L1448-MM
        const protoGroup = new THREE.Group(); protoGroup.position.set(-95000, 25000, -90000); scene.add(protoGroup);
        const protoCore = new THREE.Mesh(new THREE.SphereGeometry(20, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffaa88 }));
        protoGroup.add(protoCore);
        const envGeo = new THREE.SphereGeometry(100, 32, 32); const envMat = new THREE.MeshBasicMaterial({ color: 0x442222, transparent: true, opacity: 0.3, side: THREE.BackSide });
        protoGroup.add(new THREE.Mesh(envGeo, envMat));
        const jetGeo = new THREE.CylinderGeometry(2, 40, 800, 32, 1, true); jetGeo.translate(0, 400, 0);
        const jetMat = new THREE.MeshBasicMaterial({ color: 0xffaa44, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
        const jet1 = new THREE.Mesh(jetGeo, jetMat); jet1.rotation.z = 0.2; const jet2 = new THREE.Mesh(jetGeo, jetMat); jet2.rotation.z = 0.2; jet2.rotation.x = Math.PI;
        protoCore.add(jet1); protoCore.add(jet2);
        trackableObjects.push({ name: "L1448-MM", mesh: protoCore, type: 'star', system: 'proto', center: new THREE.Vector3(-95000, 25000, -90000) });


        // --- VFTS 102 ---
        const vftsGroup = new THREE.Group(); vftsGroup.position.copy(VFTS_OFFSET); scene.add(vftsGroup);
        const vftsGeo = new THREE.SphereGeometry(25, 64, 64);
        const vftsMat = new THREE.MeshBasicMaterial({ color: 0xaaccff, map: createPlanetTexture(0x88ccff, 'star') });
        const vfts = new THREE.Mesh(vftsGeo, vftsMat); vfts.scale.set(1.6, 0.9, 1.6);
        const vDiskGeo = new THREE.RingGeometry(28, 45, 64);
        const vDiskMat = new THREE.MeshBasicMaterial({ color: 0x88aaff, side: THREE.DoubleSide, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
        const vDisk = new THREE.Mesh(vDiskGeo, vDiskMat); vDisk.rotation.x = Math.PI/2;
        vftsGroup.add(vfts); vftsGroup.add(vDisk);
        const vftsSpriteMat = new THREE.SpriteMaterial({ map: createGlowTexture(0x88ccff), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
        const vftsSprite = new THREE.Sprite(vftsSpriteMat); vftsSprite.scale.set(300, 300, 1); vftsGroup.add(vftsSprite);
        trackableObjects.push({ name: "VFTS 102", mesh: vfts, group: vftsGroup, type: 'star', system: 'vfts', center: VFTS_OFFSET });

        // --- J1407b ---
        const j1407Group = new THREE.Group(); j1407Group.position.copy(J1407_OFFSET); scene.add(j1407Group);
        const v1400 = new THREE.Mesh(new THREE.IcosahedronGeometry(28, 10), new THREE.MeshBasicMaterial({ color: 0xffcc44, map: createPlanetTexture(0xffaa00, 'star') }));
        const v1400Flare = new THREE.Mesh(new THREE.SphereGeometry(34, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.BackSide, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending }));
        v1400.add(v1400Flare); j1407Group.add(v1400);
        
        const superSaturnContainer = new THREE.Group();
        superSaturnContainer.position.set(400, 0, 0); 
        const jPlanet = new THREE.Mesh(new THREE.SphereGeometry(12, 32, 32), new THREE.MeshStandardMaterial({ map: createPlanetTexture(0xcc9966, 'gas'), color: 0xaa8866 }));
        superSaturnContainer.add(jPlanet);
        
        const ringGroup = new THREE.Group();
        ringGroup.rotation.x = Math.PI / 6; ringGroup.rotation.y = Math.PI / 8;
        for(let i=0; i<35; i++) {
            const inner = 20 + i * 8; const outer = inner + 2 + Math.random() * 5;
            const opacity = 0.1 + Math.random() * 0.4;
            const rGeo = new THREE.RingGeometry(inner, outer, 128);
            const rMat = new THREE.MeshBasicMaterial({ color: 0xccaa88, side: THREE.DoubleSide, transparent: true, opacity: opacity, blending: THREE.AdditiveBlending });
            const rMesh = new THREE.Mesh(rGeo, rMat); rMesh.rotation.x = Math.PI / 2; ringGroup.add(rMesh);
        }
        superSaturnContainer.add(ringGroup); j1407Group.add(superSaturnContainer);
        trackableObjects.push({ name: "J1407b", mesh: jPlanet, group: superSaturnContainer, type: 'planet', system: 'j1407', dist: 400, speed: 0.005 });


        // --- ORION SECTOR ---
        const orionGroup = new THREE.Group(); orionGroup.position.copy(ORION_OFFSET); scene.add(orionGroup);
        const betelData2 = createGlowingStar(2500, 0xff3300, -15000, 20000, 0); orionGroup.add(betelData2.group);
        const bellatrixData = createGlowingStar(1000, 0x88ccff, 15000, 18000, 0); orionGroup.add(bellatrixData.group);
        const alnitakData = createGlowingStar(1500, 0x88aaff, -6000, 0, 0); orionGroup.add(alnitakData.group);
        const alnilamData = createGlowingStar(1600, 0x88aaff, 0, 0, 0); orionGroup.add(alnilamData.group);
        const mintakaData = createGlowingStar(1500, 0x88aaff, 6000, 0, 0); orionGroup.add(mintakaData.group);
        const saiphData = createGlowingStar(1200, 0x88ccff, -12000, -20000, 0); orionGroup.add(saiphData.group);
        const rigelData = createGlowingStar(2000, 0xaaccff, 12000, -22000, 0); orionGroup.add(rigelData.group);
        const points = [
            betelData2.group.position, alnitakData.group.position, bellatrixData.group.position, mintakaData.group.position,
            alnitakData.group.position, alnilamData.group.position, alnilamData.group.position, mintakaData.group.position,
            alnitakData.group.position, saiphData.group.position, mintakaData.group.position, rigelData.group.position,
            betelData2.group.position, bellatrixData.group.position, saiphData.group.position, rigelData.group.position
        ];
        const lineGeo = new THREE.BufferGeometry().setFromPoints(points); const lineMat = new THREE.LineBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.6, linewidth: 2 });
        const lines = new THREE.LineSegments(lineGeo, lineMat); orionGroup.add(lines);
        trackableObjects.push({ name: "Orion Constellation", center: ORION_OFFSET, type: 'star', system: 'orion' });
        trackableObjects.push({ name: "Betelgeuse", mesh: betelData2.mesh, type: 'star', system: 'orion', center: ORION_OFFSET });
        trackableObjects.push({ name: "Rigel", mesh: rigelData.mesh, type: 'star', system: 'orion', center: ORION_OFFSET });
        trackableObjects.push({ name: "Alnitak", mesh: alnitakData.mesh, type: 'star', system: 'orion', center: ORION_OFFSET });

        // --- TRAPPIST-1 System ---
        const trappistGroup = new THREE.Group(); trappistGroup.position.copy(TRAPPIST_OFFSET); scene.add(trappistGroup);
        const trappist = new THREE.Mesh(new THREE.IcosahedronGeometry(25, 10), new THREE.MeshBasicMaterial({ color: 0xff2200, map: createPlanetTexture(0x880000, 'star') }));
        const tFlare = new THREE.Mesh(new THREE.SphereGeometry(30, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.BackSide, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending })); trappist.add(tFlare); trappistGroup.add(trappist);
        addHZ(50, 5, trappist);
        const trapColors = [0x555555, 0xaa8866, 0x4466aa, 0x338833, 0x666666, 0xaa4444, 0x88aaff];
        const trapNames = ["b", "c", "d", "e", "f", "g", "h"];
        for(let i=0; i<7; i++) {
            const dist = 35 + i * 9; 
            const tPlanet = new THREE.Mesh(new THREE.SphereGeometry(3.0, 32, 32), new THREE.MeshStandardMaterial({ map: createPlanetTexture(trapColors[i], 'rock'), color: 0xffcccc, emissive: trapColors[i], emissiveIntensity: 0.15 }));
            const tRing = new THREE.Mesh(new THREE.RingGeometry(dist-0.3, dist+0.3, 64), new THREE.MeshBasicMaterial({color:0xaa4422, side:THREE.DoubleSide, transparent:true, opacity:0.2})); tRing.rotation.x = Math.PI/2; trappist.add(tRing);
            const tpGroup = new THREE.Group(); tpGroup.add(tPlanet); tPlanet.position.x = dist; trappist.add(tpGroup);
            trackableObjects.push({ name: "TRAPPIST-1" + trapNames[i], mesh: tPlanet, group: tpGroup, type: 'planet', system: 'trappist', dist: dist, speed: 0.05 - i*0.005, angle: Math.random()*10 });
        }
        trackableObjects.push({ name: "TRAPPIST-1", mesh: trappist, group: trappistGroup, type: 'star', system: 'trappist', center: TRAPPIST_OFFSET });

        const neb1Core = new THREE.Mesh(new THREE.SphereGeometry(10), new THREE.MeshBasicMaterial({color:0xff0088, transparent:true, opacity:0})); neb1Core.position.copy(NEBULA1_OFFSET); scene.add(neb1Core);
        const neb2Core = new THREE.Mesh(new THREE.SphereGeometry(10), new THREE.MeshBasicMaterial({color:0x00ffaa, transparent:true, opacity:0})); neb2Core.position.copy(NEBULA2_OFFSET); scene.add(neb2Core);
        trackableObjects.push({ name: "Orion Nebula", mesh: neb1Core, type: 'star', system: 'nebula', center: NEBULA1_OFFSET });
        trackableObjects.push({ name: "Crab Nebula", mesh: neb2Core, type: 'star', system: 'nebula', center: NEBULA2_OFFSET });

        // --- Solar System Planets ---
        const planetsData = [
            { name: "Mercury", dist: 50, size: 2.5, color: 0xaaaaaa, type: 'rock', speed: 0.04 }, 
            { name: "Venus", dist: 70, size: 4.5, color: 0xffcc00, type: 'gas', speed: 0.025 }, 
            { name: "Earth", dist: 100, size: 4.8, color: 0x2266ff, type: 'rock', speed: 0.018, moons: [{name:"Moon", dist:12, size:2.0}] },
            { name: "Mars", dist: 130, size: 3.0, color: 0xff4422, type: 'rock', speed: 0.014 }, 
            { name: "Jupiter", dist: 190, size: 14.0, color: 0xccaebb, type: 'gas', speed: 0.006, moons: [{name:"Io", dist:22, size:2.0}] },
            { name: "Saturn", dist: 260, size: 12.0, color: 0xe0d0a0, type: 'gas', speed: 0.004, ring: true }, 
            { name: "Uranus", dist: 340, size: 8.0, color: 0x66ccff, type: 'gas', speed: 0.002 },
            { name: "Neptune", dist: 400, size: 7.8, color: 0x3355ff, type: 'gas', speed: 0.001 }, 
            { name: "Pluto", dist: 480, size: 2.2, color: 0xddccbb, type: 'rock', speed: 0.0008, inclination: 0.15 },
            { name: "Haumea", dist: 540, size: 2.0, color: 0xeeeeee, type: 'ice', speed: 0.0007, inclination: 0.2, shape: 'oval' },
            { name: "Makemake", dist: 600, size: 2.1, color: 0xffaa88, type: 'ice', speed: 0.0006, inclination: 0.25 },
            { name: "Eris", dist: 750, size: 2.3, color: 0xffffff, type: 'ice', speed: 0.0004, inclination: 0.35 },
            { name: "Sedna", dist: 1100, size: 3.0, color: 0xaa3322, type: 'rock', speed: 0.0002, inclination: 0.1 }
        ];
        const orbitMat = new THREE.MeshBasicMaterial({ color: 0x4466ff, side: THREE.DoubleSide, transparent: true, opacity: 0.15 });
        planetsData.forEach(data => {
            const orbitGroup = new THREE.Group();
            if (data.inclination) { orbitGroup.rotation.z = data.inclination * Math.PI; orbitGroup.rotation.x = Math.random() * 0.2; }
            scene.add(orbitGroup);
            const path = new THREE.Mesh(new THREE.RingGeometry(data.dist - 0.4, data.dist + 0.4, 128), orbitMat); path.rotation.x = Math.PI / 2; orbitGroup.add(path);
            let geo; if(data.shape === 'oval') { geo = new THREE.SphereGeometry(data.size, 32, 32); geo.scale(2.0, 1.0, 1.0); } else { geo = new THREE.SphereGeometry(data.size, 32, 32); }
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ map: createPlanetTexture(data.color, data.type), roughness: 0.6, emissive: data.color, emissiveIntensity: 0.15 }));
            orbitGroup.add(mesh);
            if (data.ring) { const ring = new THREE.Mesh(new THREE.RingGeometry(data.size*1.4, data.size*2.2, 64), new THREE.MeshBasicMaterial({ color: 0xccbb99, side: THREE.DoubleSide, transparent: true, opacity: 0.8 })); ring.rotation.x = Math.PI / 2; mesh.add(ring); }
            const planetObj = { name: data.name, mesh: mesh, group: orbitGroup, dist: data.dist, speed: data.speed, angle: Math.random() * 10, type: 'planet', isOval: data.shape === 'oval' };
            trackableObjects.push(planetObj);
            if(data.moons) { planetObj.moons = []; data.moons.forEach(m => { const mMesh = new THREE.Mesh(new THREE.SphereGeometry(m.size), new THREE.MeshStandardMaterial({ color: 0xcccccc })); orbitGroup.add(mMesh); planetObj.moons.push({ mesh: mMesh, dist: m.dist, speed: 0.05, angle: Math.random() }); }); }
        });

        const halleyGroup = new THREE.Group(); halleyGroup.rotation.z = THREE.MathUtils.degToRad(160); scene.add(halleyGroup);
        const halleyPath = new THREE.Mesh(new THREE.RingGeometry(90, 90.5, 128), new THREE.MeshBasicMaterial({color:0x88ffaa, transparent:true, opacity:0.2, side:THREE.DoubleSide})); halleyPath.position.x=60; halleyPath.rotation.x=Math.PI/2; halleyGroup.add(halleyPath);
        const halleyMesh = new THREE.Mesh(new THREE.SphereGeometry(2.0, 16, 16), new THREE.MeshStandardMaterial({ map: createPlanetTexture(0xccffdd, 'comet'), roughness: 0.4, emissive: 0xccffdd, emissiveIntensity: 0.2 }));
        const tailGeo = new THREE.ConeGeometry(2, 30, 32, 1, true); const tailMesh = new THREE.Mesh(tailGeo, new THREE.MeshBasicMaterial({ color: 0xccffdd, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending })); tailMesh.rotation.x = -Math.PI/2; tailMesh.position.z = -15; halleyMesh.add(tailMesh); halleyGroup.add(halleyMesh);
        trackableObjects.push({ name: "Halley's Comet", mesh: halleyMesh, group: halleyGroup, type: 'comet', dist: 0, speed: 0.2, angle: 0, cx: 60, a: 90, b: 30 });

        const centauriGroup = new THREE.Group(); centauriGroup.position.copy(ALPHA_OFFSET); scene.add(centauriGroup);
        const alphaA = new THREE.Mesh(new THREE.IcosahedronGeometry(32, 10), new THREE.MeshBasicMaterial({ color: 0xffdd88, map: createPlanetTexture(0xffaa00, 'star') }));
        const alphaAFlare = new THREE.Mesh(new THREE.SphereGeometry(38, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.BackSide, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending })); alphaA.add(alphaAFlare); centauriGroup.add(alphaA);
        const alphaB = new THREE.Mesh(new THREE.IcosahedronGeometry(24, 10), new THREE.MeshBasicMaterial({ color: 0xffaa55, map: createPlanetTexture(0xff8800, 'star') })); alphaB.add(alphaAFlare.clone());
        const bOrbit = new THREE.Group(); bOrbit.add(alphaB); alphaB.position.set(200, 0, 0); centauriGroup.add(bOrbit);
        addHZ(100, 15, alphaA);

        const proximaGroup = new THREE.Group(); proximaGroup.position.copy(PROXIMA_OFFSET); scene.add(proximaGroup);
        const proxima = new THREE.Mesh(new THREE.IcosahedronGeometry(10, 10), new THREE.MeshBasicMaterial({ color: 0xff2200, map: createPlanetTexture(0xaa0000, 'star') }));
        const proximaFlare = new THREE.Mesh(new THREE.SphereGeometry(14, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.BackSide, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending })); proxima.add(proximaFlare); proximaGroup.add(proxima);
        const proximaB = new THREE.Mesh(new THREE.SphereGeometry(3.0, 32, 32), new THREE.MeshStandardMaterial({ map: createPlanetTexture(0xaa8866, 'rock'), color: 0xffcccc, emissive: 0xffcccc, emissiveIntensity: 0.1 }));
        const pbOrbit = new THREE.Group(); pbOrbit.add(proximaB); proximaB.position.set(20, 0, 0); proximaGroup.add(pbOrbit);
        addHZ(20, 3, proxima);

        const gliese = new THREE.Mesh(new THREE.IcosahedronGeometry(22, 10), new THREE.MeshBasicMaterial({ color: 0xffaa55, map: createPlanetTexture(0xff8800, 'star') }));
        gliese.position.copy(GLIESE_OFFSET); const glieseFlare = new THREE.Mesh(new THREE.SphereGeometry(26, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff6600, side: THREE.BackSide, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending })); gliese.add(glieseFlare); scene.add(gliese);

        const siriusGroup = new THREE.Group(); siriusGroup.position.copy(SIRIUS_OFFSET); scene.add(siriusGroup);
        const siriusA = new THREE.Mesh(new THREE.IcosahedronGeometry(45, 10), new THREE.MeshBasicMaterial({ color: 0xaaccff, map: createPlanetTexture(0x88aaff, 'star') }));
        const siriusAFlare = new THREE.Mesh(new THREE.SphereGeometry(55, 32, 32), new THREE.MeshBasicMaterial({ color: 0x88aaff, side: THREE.BackSide, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending })); siriusA.add(siriusAFlare); siriusGroup.add(siriusA);
        const siriusB = new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        const siriusBFlare = new THREE.Mesh(new THREE.SphereGeometry(8, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending })); siriusB.add(siriusBFlare);
        const sbOrbit = new THREE.Group(); sbOrbit.add(siriusB); siriusB.position.set(300, 0, 0); siriusGroup.add(sbOrbit);
        addHZ(150, 20, siriusA);

        const bhGroup = new THREE.Group(); bhGroup.position.copy(BLACKHOLE_OFFSET); bhGroup.rotation.x = 0.5; scene.add(bhGroup);
        const bhCore = new THREE.Mesh(new THREE.SphereGeometry(30, 32, 32), new THREE.MeshBasicMaterial({ color: 0x000000 })); bhGroup.add(bhCore);
        const disk = new THREE.Mesh(new THREE.RingGeometry(40, 120, 64), new THREE.MeshBasicMaterial({ color: 0xaa00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending })); disk.rotation.x = Math.PI/2; bhGroup.add(disk);
        const innerDisk = new THREE.Mesh(new THREE.RingGeometry(32, 45, 64), new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.DoubleSide, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending })); innerDisk.rotation.x = Math.PI/2; bhGroup.add(innerDisk);

        const pulsarGroup = new THREE.Group(); pulsarGroup.position.copy(PULSAR_OFFSET); scene.add(pulsarGroup);
        const pulsarCore = new THREE.Mesh(new THREE.SphereGeometry(8, 32, 32), new THREE.MeshBasicMaterial({ color: 0x88ffff, map: createPlanetTexture(0x00ffff, 'pulsar') })); pulsarGroup.add(pulsarCore);
        const beamGeo = new THREE.ConeGeometry(4, 400, 32, 1, true); beamGeo.translate(0, 200, 0);
        const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
        const beam1 = new THREE.Mesh(beamGeo, beamMat); pulsarCore.add(beam1);

        trackableObjects.push({ name: "Alpha Centauri A", mesh: alphaA, group: centauriGroup, type: 'star', system: 'centauri', center: ALPHA_OFFSET });
        trackableObjects.push({ name: "Alpha Centauri B", mesh: alphaB, group: bOrbit, type: 'star', system: 'centauri', center: ALPHA_OFFSET });
        trackableObjects.push({ name: "Proxima Centauri", mesh: proxima, group: proximaGroup, type: 'star', system: 'proxima', center: PROXIMA_OFFSET });
        trackableObjects.push({ name: "Gliese 710", mesh: gliese, type: 'star', system: 'gliese', center: GLIESE_OFFSET });
        trackableObjects.push({ name: "Sirius A", mesh: siriusA, type: 'star', system: 'sirius', center: SIRIUS_OFFSET });
        trackableObjects.push({ name: "Sirius B", mesh: siriusB, type: 'star', system: 'sirius', center: SIRIUS_OFFSET });
        trackableObjects.push({ name: "Black Hole", mesh: bhCore, type: 'star', system: 'blackhole', center: BLACKHOLE_OFFSET });
        trackableObjects.push({ name: "Pulsar", mesh: pulsarCore, type: 'star', system: 'pulsar', center: PULSAR_OFFSET });
        trackableObjects.push({ name: "VFTS 102", mesh: vfts, group: vftsGroup, type: 'star', system: 'vfts', center: VFTS_OFFSET });
        trackableObjects.push({ name: "J1407b", mesh: jPlanet, group: superSaturnContainer, type: 'planet', system: 'j1407', dist: 400, speed: 0.005 });

        const targetListEl = document.getElementById('target-list');
        const monitorEl = document.getElementById('data-monitor');
        const elName = document.getElementById('monitor-name'); const elClass = document.getElementById('monitor-class'); const elSize = document.getElementById('monitor-size'); const elTemp = document.getElementById('monitor-temp'); const elDist = document.getElementById('monitor-dist'); const elDesc = document.getElementById('data-desc');
        
        let timeScale = 1.0;
        document.getElementById('time-slider').addEventListener('input', (e) => { timeScale = parseFloat(e.target.value); document.getElementById('speed-display').innerText = timeScale.toFixed(1) + "x"; });
        
        let hzVisible = false;
        const hzToggleBtn = document.getElementById('hz-toggle');
        hzToggleBtn.onclick = () => { hzVisible = !hzVisible; hzToggleBtn.innerText = "HABITABLE ZONE: " + (hzVisible ? "ON" : "OFF"); hzToggleBtn.className = "toggle-btn " + (hzVisible ? "" : "off"); hzMaterial.opacity = hzVisible ? 0.3 : 0.0; };

        let hzInterval; 

        function updateMonitor(obj) {
            monitorEl.style.display = 'block';
            const info = infoDatabase[obj.name] || { class: "Unknown", size: "-", temp: "-", desc: "データなし。" };
            elName.innerText = obj.name.toUpperCase();
            elClass.innerText = info.class; elSize.innerText = info.size; elTemp.innerText = info.temp;
            let distDisplay = "";
            if (obj.system === 'centauri') distDisplay = "4.37 光年"; else if (obj.system === 'proxima') distDisplay = "4.24 光年"; else if (obj.system === 'trappist') distDisplay = "40 光年"; else if (obj.system === 'nebula') distDisplay = "1,300+ 光年"; else if (obj.system === 'orion') distDisplay = "~640 光年"; else if (obj.system === 'vfts') distDisplay = "16万 光年"; else if (obj.system === 'j1407') distDisplay = "434 光年"; else if (obj.system === 'pleiades') distDisplay = "444 光年"; else if (obj.system === 'proto') distDisplay = "1000 光年"; else distDisplay = Math.round(obj.dist * 1000000).toLocaleString() + " km (Sim)";
            elDist.innerText = distDisplay;
            
            // Typewriter
            if (hzInterval) clearInterval(hzInterval);
            elDesc.innerHTML = '<span class="cursor"></span>';
            const text = info.desc;
            let i = 0;
            hzInterval = setInterval(() => { elDesc.innerText = text.substring(0, i) + (i < text.length ? '█' : ''); i++; if (i > text.length) clearInterval(hzInterval); }, 20); 
        }

        function createNavGroup(title, items, styleClass = '') {
            const groupDiv = document.createElement('div'); groupDiv.className = 'nav-group';
            const titleDiv = document.createElement('div'); titleDiv.className = 'nav-group-title'; titleDiv.innerText = title; groupDiv.appendChild(titleDiv);
            items.forEach(obj => { const btn = document.createElement('button'); btn.className = 'target-btn ' + styleClass; btn.innerText = obj.name; btn.onclick = () => setTarget(obj, btn); groupDiv.appendChild(btn); });
            targetListEl.appendChild(groupDiv);
        }

        createNavGroup("Inner System", trackableObjects.filter(p => p.type === 'planet' && p.dist < 150 && !p.system));
        createNavGroup("Gas Giants", trackableObjects.filter(p => p.type === 'planet' && p.dist >= 150 && p.dist < 450));
        createNavGroup("Outer Rim", trackableObjects.filter(p => p.type === 'planet' && p.dist >= 450));
        createNavGroup("Comets", trackableObjects.filter(p => p.type === 'comet'), 'comet-btn');
        createNavGroup("Probes", trackableObjects.filter(p => p.type === 'probe'));
        createNavGroup("Nearby Stars", trackableObjects.filter(p => p.system === 'centauri' || p.system === 'proxima' || p.system === 'sirius' || p.system === 'gliese'), 'warp-active');
        createNavGroup("Exotic Systems", trackableObjects.filter(p => p.system === 'j1407' || p.system === 'trappist'), 'super-ring-btn');
        createNavGroup("Stellar Nursery", trackableObjects.filter(p => p.system === 'pleiades' || p.system === 'proto'), 'pleiades-btn');
        createNavGroup("Orion Constellation", trackableObjects.filter(p => p.system === 'orion'), 'orion-btn');
        createNavGroup("Extreme Stars", trackableObjects.filter(p => p.system === 'vfts'), 'super-ring-btn');
        createNavGroup("Deep Space", trackableObjects.filter(p => p.system === 'nebula' || p.system === 'blackhole' || p.system === 'pulsar'), 'nebula-btn');

        document.getElementById('reset-btn').onclick = () => { currentTarget = null; controls.target.set(0,0,0); camera.position.copy(initialCamPos); document.querySelectorAll('.target-btn').forEach(b => b.classList.remove('active')); monitorEl.style.display = 'none'; };

        function setTarget(obj, btnElement) {
            document.querySelectorAll('.target-btn').forEach(b => b.classList.remove('active')); if(btnElement) btnElement.classList.add('active');
            currentTarget = obj; updateMonitor(obj);
            
            let targetPos = new THREE.Vector3();
            if (obj.center) targetPos.copy(obj.center); else if (obj.type === 'planet' || obj.type === 'comet') obj.mesh.getWorldPosition(targetPos); else obj.container.getWorldPosition(targetPos);
            
            controls.target.copy(targetPos); // INSTANT LOCK-ON (No Fly)
            
            let offsetScalar = 40; 
            if(obj.type === 'star') offsetScalar = 100;
            if(obj.system === 'trappist') offsetScalar = 80; 
            if(obj.system === 'orion') offsetScalar = 4000;
            if(obj.system === 'vfts') offsetScalar = 300;
            if(obj.system === 'j1407') offsetScalar = 400; 
            if(obj.system === 'pleiades') offsetScalar = 2000;

            camera.position.copy(targetPos.clone().add(new THREE.Vector3(offsetScalar, offsetScalar/2, offsetScalar)));
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const speed = timeScale; 

            milkyWay.rotation.y += 0.0001 * speed;
            centauriGroup.children.forEach(child => { if(child.children.length > 0) child.rotation.y += 0.002 * speed; }); 
            proximaGroup.children.forEach(c => { if(c.children.length>0) c.rotation.y += 0.02 * speed; }); 
            bhGroup.children.forEach(c => { if(c.geometry.type === 'RingGeometry') c.rotation.z -= 0.02 * speed; });
            pulsarGroup.children[0].rotation.z -= 0.2 * speed; pulsarGroup.children[0].rotation.x = Math.sin(time*2)*0.2;
            vfts.rotation.y += 0.2 * speed; vDisk.rotation.z += 0.1 * speed;

            trappist.children.forEach(c => { if(c.type === 'Group') c.rotation.y += (0.05 / (c.children[0].position.x/10)) * speed; });
            if(betelData2.mesh) { const pulse = 1 + Math.sin(time) * 0.05; betelData2.mesh.scale.set(1+pulse*0.1, 1+pulse*0.1, 1+pulse*0.1); }

            trackableObjects.forEach(obj => {
                if(obj.type === 'planet' && !obj.system) {
                    obj.angle += obj.speed * 0.5 * speed; obj.mesh.position.x = Math.cos(obj.angle) * obj.dist; obj.mesh.position.z = Math.sin(obj.angle) * obj.dist; obj.mesh.rotation.y += 0.01 * speed;
                    if(obj.moons) { obj.moons.forEach(m => { m.angle += m.speed * 0.5 * speed; m.mesh.position.x = obj.mesh.position.x + Math.cos(m.angle) * m.dist; m.mesh.position.z = obj.mesh.position.z + Math.sin(m.angle) * m.dist; }); }
                } else if (obj.type === 'comet') {
                    obj.angle += obj.speed * 0.1 * speed;
                    const x = obj.cx - obj.a * Math.cos(obj.angle); const z = obj.b * Math.sin(obj.angle);
                    obj.mesh.position.set(x, 0, z); obj.mesh.lookAt(0,0,0); obj.mesh.rotateY(Math.PI);
                } else if (obj.type === 'probe') {
                    obj.angle += obj.speed * 0.5 * speed; 
                    obj.container.position.x = Math.cos(obj.angle) * obj.dist; obj.container.position.z = Math.sin(obj.angle) * obj.dist; 
                    obj.container.rotation.y += 0.02 * speed; obj.targetRing.rotation.x = Math.sin(time * 2) * 0.5; obj.targetRing.rotation.y += 0.05 * speed;
                }
            });

            if (currentTarget) {
                let targetPos = new THREE.Vector3();
                if(currentTarget.center) targetPos.copy(currentTarget.center); 
                else if (currentTarget.type === 'planet' || currentTarget.type === 'comet') currentTarget.mesh.getWorldPosition(targetPos); 
                else currentTarget.container.getWorldPosition(targetPos);
                
                controls.target.lerp(targetPos, 0.1); 
            }
            controls.update(); composer.render();
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>